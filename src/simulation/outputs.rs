/*
 * Cymbalum, Molecular Simulation in Rust
 * Copyright (C) 2015 Guillaume Fraux
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/
*/
use std::io::prelude::*;
use std::fs::File;

use ::units;
use ::universe::Universe;

/// The `Output` trait define the interface for all the quantities outputed by
/// the simulation during the run. An Output can be a text or a binary data
/// file, an image, a text log, â€¦
pub trait Output {
    /// Function called once at the beggining of the simulation, which allow
    /// for some setup of the output if needed.
    fn setup(&mut self, _: &Universe) {}

    /// Write the output from the universe.
    fn write(&mut self, universe: &Universe);

    /// Function called once at the end of the simulation.
    fn finish(&mut self, _: &Universe) {}
}

/******************************************************************************/
/// The `TrajectoryOutput` allow to write the trajectory of the system to a
/// file, using the XYZ format.
pub struct TrajectoryOutput {
    file: File,
}

impl TrajectoryOutput {
    /// Create a new `TrajectoryOutput`, using the file ate `filename` for
    /// as the trajectory file. The file is replaced if it already exists.
    pub fn new<'a, S>(filename: S) -> TrajectoryOutput where S: Into<&'a str> {
        TrajectoryOutput{
            file: File::create(filename.into()).unwrap()
        }
    }
}

impl Output for TrajectoryOutput {
    fn write(&mut self, universe: &Universe) {
        writeln!(&mut self.file, "{}", universe.size()).unwrap();
        writeln!(&mut self.file, "Generated by cymbalum \\o/").unwrap();
        for n in 0..universe.size() {
            let part = &universe[n];
            let pos = part.position();
            writeln!(&mut self.file, "{} {} {} {}", part.name(), pos.x, pos.y, pos.z).unwrap();
        }
    }
}

/******************************************************************************/
/// The `EnergyOutput` write the energy of the system to a text file, organized
/// as: `PotentialEnergy     KineticEnergy     TotalEnergy`.
pub struct EnergyOutput {
    file: File,
}

impl EnergyOutput {
    /// Create a new `TrajectoryOutput`, using the file ate `filename` for
    /// output.
    pub fn new<'a, S>(filename: S) -> EnergyOutput where S: Into<&'a str> {
        EnergyOutput{
            file: File::create(filename.into()).unwrap()
        }
    }
}

impl Output for EnergyOutput {
    fn setup(&mut self, _: &Universe) {
        writeln!(&mut self.file, "# Energy of the simulation (kJ/mol)").unwrap();
        writeln!(&mut self.file, "# Potential     Kinetic     Total").unwrap();
    }

    fn write(&mut self, universe: &Universe) {
        let potential = units::to(universe.potential_energy(), "kJ/mol").unwrap();
        let kinetic = units::to(universe.kinetic_energy(), "kJ/mol").unwrap();
        let total = units::to(universe.total_energy(), "kJ/mol").unwrap();
        writeln!(&mut self.file, "{}   {}   {}", potential, kinetic, total).unwrap();
    }
}
